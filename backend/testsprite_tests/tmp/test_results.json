[
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "805cb6c3-56f9-4895-b855-de3def9296a3",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC001-dev login should return valid jwt token",
    "description": "Test the /api/v1/auth/dev-login POST endpoint to verify that it accepts a userId and optional role, and returns a valid JWT access token for development login.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTIMEOUT = 30\n\ndef test_dev_login_should_return_valid_jwt_token():\n    url = f\"{BASE_URL}/api/v1/auth/dev-login\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"userId\": \"test-user\",\n        \"role\": \"ROLE_DEV\"\n    }\n\n    response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n    json_data = response.json()\n    assert \"accessToken\" in json_data, \"Response JSON missing 'accessToken'\"\n\n    token = json_data[\"accessToken\"]\n    assert isinstance(token, str) and len(token) > 0, \"'accessToken' should be a non-empty string\"\n\n    # Verify if token is a valid JWT structure (header.payload.signature)\n    parts = token.split('.')\n    assert len(parts) == 3, \"accessToken is not a valid JWT format\"\n\n\ntest_dev_login_should_return_valid_jwt_token()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.122Z",
    "modified": "2025-12-23T13:02:58.686Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "627ad685-be58-4901-a44d-73add76653f2",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC002-processes get should list_all_non_deleted_processes",
    "description": "Test the /api/v1/processes GET endpoint to ensure it returns a list of all processes excluding those marked as soft deleted (deleted_at IS NULL filter applied).",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_processes_get_should_list_all_non_deleted_processes():\n    url = f\"{BASE_URL}/api/v1/processes\"\n    try:\n        response = requests.get(url, headers=HEADERS, timeout=30)\n        assert response.status_code == 200, f\"Expected status 200 OK but got {response.status_code}\"\n        json_data = response.json()\n        assert isinstance(json_data, list), \"Response is not a list\"\n        # Check that none of the returned processes have a deleted_at field set (soft deleted)\n        for process in json_data:\n            # We allow deleted_at to be missing or None\n            deleted_at = process.get(\"deleted_at\", None)\n            assert deleted_at is None, f\"Found soft deleted process with id={process.get('id')} in the list\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_processes_get_should_list_all_non_deleted_processes()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.126Z",
    "modified": "2025-12-23T13:02:48.041Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "98b296c0-b703-4fc4-b245-b005f3a9a94d",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC003-processes post should create_new_process_with_valid_data",
    "description": "Test the /api/v1/processes POST endpoint to create a new process with valid input data and verify the process is stored correctly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nPROCESS_ENDPOINT = f\"{BASE_URL}/api/v1/processes\"\nAUTH_TOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {AUTH_TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_processes_post_should_create_new_process_with_valid_data():\n    # Define valid process data payload with required 'name' and 'order' fields\n    process_data = {\n        \"name\": \"Test Process\",\n        \"order\": 1\n    }\n    created_process_id = None\n\n    try:\n        # Create a new process via POST\n        response = requests.post(\n            PROCESS_ENDPOINT,\n            headers=HEADERS,\n            json=process_data,\n            timeout=30\n        )\n        assert response.status_code in (200, 201), f\"Unexpected status code: {response.status_code}, Response: {response.text}\"\n        created_process = response.json()\n        # Validate that the response contains expected fields and matches input\n        assert \"id\" in created_process and created_process[\"id\"] is not None, \"Response missing 'id'\"\n        assert created_process.get(\"name\") == process_data[\"name\"], \"Process name mismatch\"\n\n        created_process_id = created_process[\"id\"]\n\n        # Retrieve the newly created process to verify it is stored correctly\n        get_url = f\"{PROCESS_ENDPOINT}/{created_process_id}\"\n        get_response = requests.get(get_url, headers=HEADERS, timeout=30)\n        assert get_response.status_code == 200, f\"Failed to get created process, status code: {get_response.status_code}\"\n        retrieved_process = get_response.json()\n        assert retrieved_process.get(\"id\") == created_process_id, \"Retrieved process ID mismatch\"\n        assert retrieved_process.get(\"name\") == process_data[\"name\"], \"Retrieved process name mismatch\"\n\n    finally:\n        # Clean up: delete the created process if it was made\n        if created_process_id:\n            delete_url = f\"{PROCESS_ENDPOINT}/{created_process_id}\"\n            delete_response = requests.delete(delete_url, headers=HEADERS, timeout=30)\n            # Soft delete expected: status code 200 or 204\n            assert delete_response.status_code in [200, 204], f\"Failed to delete process, status code: {delete_response.status_code}\"\n\n\ntest_processes_post_should_create_new_process_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 53, in <module>\n  File \"<string>\", line 28, in test_processes_post_should_create_new_process_with_valid_data\nAssertionError: Unexpected status code: 400, Response: {\"type\":\"about:blank\",\"title\":\"Bad Request\",\"status\":400,\"detail\":\"Invalid request content.\",\"instance\":\"/api/v1/processes\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.131Z",
    "modified": "2025-12-23T13:03:27.795Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "ca4bbc44-18ea-4491-bca6-36637d06c3b3",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC004-processes id put should update_existing_process",
    "description": "Test the /api/v1/processes/{id} PUT endpoint to update an existing process by id and verify the changes are persisted.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\n\ndef test_processes_id_put_should_update_existing_process():\n    # First create a new process to update\n    create_payload = {\n        \"name\": \"Initial Process Name\"\n    }\n    create_resp = requests.post(\n        f\"{BASE_URL}/api/v1/processes\",\n        headers=HEADERS,\n        json=create_payload,\n        timeout=TIMEOUT\n    )\n    assert create_resp.status_code == 201, f\"Failed to create process for update test: {create_resp.text}\"\n    created_process = create_resp.json()\n    process_id = created_process.get(\"id\")\n    assert process_id is not None, \"Created process ID is None\"\n\n    try:\n        # Prepare updated data\n        updated_payload = {\n            \"name\": \"Updated Process Name\"\n        }\n\n        # Perform PUT request to update the process\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/v1/processes/{process_id}\",\n            headers=HEADERS,\n            json=updated_payload,\n            timeout=TIMEOUT\n        )\n        assert update_resp.status_code == 200, f\"Update failed: {update_resp.text}\"\n        updated_process = update_resp.json()\n\n        # Verify the updated fields\n        assert updated_process.get(\"name\") == updated_payload[\"name\"], \"Process name was not updated correctly\"\n\n        # Retrieve the process again to verify persistence\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/v1/processes/{process_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert get_resp.status_code == 200, f\"Failed to get process after update: {get_resp.text}\"\n        fetched_process = get_resp.json()\n        assert fetched_process.get(\"name\") == updated_payload[\"name\"], \"Persisted process name mismatch\"\n\n    finally:\n        # Clean up by deleting the created process\n        requests.delete(\n            f\"{BASE_URL}/api/v1/processes/{process_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n\n\ntest_processes_id_put_should_update_existing_process()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 23, in test_processes_id_put_should_update_existing_process\nAssertionError: Failed to create process for update test: {\"type\":\"about:blank\",\"title\":\"Bad Request\",\"status\":400,\"detail\":\"Invalid request content.\",\"instance\":\"/api/v1/processes\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.135Z",
    "modified": "2025-12-23T13:03:27.791Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "4a58be77-b1fc-4bf4-a117-a878ff851592",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC005-processes id delete should soft_delete_process",
    "description": "Test the /api/v1/processes/{id} DELETE endpoint to soft delete a process by setting deleted_at and ensure it no longer appears in list or search results.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:8080\"\nHEADERS = {\n    \"Authorization\": \"Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\",\n    \"Content-Type\": \"application/json\",\n}\nTIMEOUT = 30\n\ndef test_processes_id_delete_should_soft_delete_process():\n    # Step 1: Create a new process (since no process id is provided).\n    create_payload = {\n        \"name\": f\"Test Process {str(uuid.uuid4())[:8]}\"\n    }\n    process_id = None\n\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/v1/processes\",\n            json=create_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201 or create_resp.status_code == 200, f\"Create process failed: {create_resp.text}\"\n        process_data = create_resp.json()\n        # The created resource id should be in the response, either 'id' or '_id'\n        process_id = process_data.get(\"id\") or process_data.get(\"_id\") or process_data.get(\"processId\")\n        assert process_id is not None, \"Created process ID not found in response\"\n\n        # Step 2: Delete (soft delete) the created process.\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/api/v1/processes/{process_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert delete_resp.status_code == 200 or delete_resp.status_code == 204, f\"Delete (soft) process failed: {delete_resp.text}\"\n\n        # Step 3: Verify the process no longer appears in the list (GET /api/v1/processes).\n        list_resp = requests.get(\n            f\"{BASE_URL}/api/v1/processes\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert list_resp.status_code == 200, f\"Get process list failed: {list_resp.text}\"\n        processes = list_resp.json()\n        # Expecting a list/array in response, filter by id to ensure soft deleted process is excluded\n        assert isinstance(processes, list), f\"Processes response not a list: {processes}\"\n        ids_in_list = [p.get(\"id\") or p.get(\"_id\") or p.get(\"processId\") for p in processes]\n        assert process_id not in ids_in_list, \"Soft deleted process still appears in process list\"\n\n    finally:\n        # Cleanup: Attempt to delete the resource permanently if API supports or ignore errors if already deleted\n        if process_id is not None:\n            # No explicit permanent delete API given, so ignore or attempt delete again quietly\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/v1/processes/{process_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n            except Exception:\n                pass\n\ntest_processes_id_delete_should_soft_delete_process()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 66, in <module>\n  File \"<string>\", line 26, in test_processes_id_delete_should_soft_delete_process\nAssertionError: Create process failed: {\"type\":\"about:blank\",\"title\":\"Bad Request\",\"status\":400,\"detail\":\"Invalid request content.\",\"instance\":\"/api/v1/processes\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.140Z",
    "modified": "2025-12-23T13:03:20.119Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "8fb5414e-5abf-4d38-b868-9a3d0531002a",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC006-terms get should search_terms_with_filters_excluding_deleted",
    "description": "Test the /api/v1/terms GET endpoint to perform keyword, process, and initial filters on terms and verify that soft deleted terms are excluded.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_terms_get_should_search_terms_with_filters_excluding_deleted():\n    # Setup: Create a term that is not deleted to be used in filter tests\n    create_term_payload = {\n        \"name_ko\": \"테스트용어\",\n        \"name_en\": \"TestTerm\",\n        \"initial_en\": \"T\",\n        \"processes\": [1],  # Assuming process with id 1 exists\n        \"description\": \"A term used for testing\",\n        \"abbreviation\": \"TT\",\n        \"synonyms\": [\"TestTermSyn\"],\n        \"hashtags\": [\"#test\"],\n        # no deleted_at to indicate not deleted\n    }\n    term_id = None\n\n    try:\n        # Create a new term\n        resp_create = requests.post(\n            f\"{BASE_URL}/api/v1/terms\",\n            json=create_term_payload,\n            headers=HEADERS,\n            timeout=30\n        )\n        assert resp_create.status_code == 201, f\"Failed to create term, status: {resp_create.status_code}, body: {resp_create.text}\"\n        term_id = resp_create.json().get(\"id\")\n        assert term_id is not None, \"Created term id is None\"\n\n        # Also create a soft deleted term by creating then deleting it\n        resp_create_del = requests.post(\n            f\"{BASE_URL}/api/v1/terms\",\n            json={\n                \"name_ko\": \"삭제된용어\",\n                \"name_en\": \"DeletedTerm\",\n                \"initial_en\": \"D\",\n                \"processes\": [1],\n                \"description\": \"A soft deleted term for testing exclusion\",\n                \"abbreviation\": \"DT\",\n                \"synonyms\": [],\n                \"hashtags\": []\n            },\n            headers=HEADERS,\n            timeout=30\n        )\n        assert resp_create_del.status_code == 201, f\"Failed to create term for deletion, status: {resp_create_del.status_code}, body: {resp_create_del.text}\"\n        deleted_term_id = resp_create_del.json().get(\"id\")\n        assert deleted_term_id is not None, \"Created term for deletion id is None\"\n\n        # Soft delete the term (soft delete means setting deleted_at; API expects DELETE)\n        resp_delete = requests.delete(\n            f\"{BASE_URL}/api/v1/terms/{deleted_term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert resp_delete.status_code == 204, f\"Failed to soft delete term, status: {resp_delete.status_code}, body: {resp_delete.text}\"\n\n        # Test searching terms with filters:\n        # keyword = \"Test\"\n        # process = 1\n        # initial = \"T\"\n        params = {\n            \"keyword\": \"Test\",\n            \"process\": 1,\n            \"initial\": \"T\"\n        }\n        resp_search = requests.get(\n            f\"{BASE_URL}/api/v1/terms\",\n            headers=HEADERS,\n            params=params,\n            timeout=30\n        )\n        assert resp_search.status_code == 200, f\"Search request failed, status: {resp_search.status_code}, body: {resp_search.text}\"\n        terms = resp_search.json()\n        assert isinstance(terms, list), \"Search response is not a list\"\n\n        # Check that the created non-deleted term is included\n        included = any(t.get(\"id\") == term_id for t in terms)\n        assert included, \"Created term not found in search results\"\n\n        # Check that the soft deleted term is excluded\n        excluded = all(t.get(\"id\") != deleted_term_id for t in terms)\n        assert excluded, \"Deleted term found in search results\"\n\n    finally:\n        # Cleanup: Delete the created non-deleted term if exists\n        if term_id:\n            delete_resp = requests.delete(\n                f\"{BASE_URL}/api/v1/terms/{term_id}\",\n                headers=HEADERS,\n                timeout=30\n            )\n            # Accept 204 No Content or 404 Not Found if already deleted\n            assert delete_resp.status_code in (204, 404), f\"Failed cleanup delete of term_id={term_id}\"\n\n        # Cleanup: Delete the soft deleted term forcibly if needed (in case soft delete did not persist)\n        if 'deleted_term_id' in locals() and deleted_term_id:\n            # Try deleting again to clean up if 404 not returned before\n            requests.delete(\n                f\"{BASE_URL}/api/v1/terms/{deleted_term_id}\",\n                headers=HEADERS,\n                timeout=30\n            )\n\ntest_terms_get_should_search_terms_with_filters_excluding_deleted()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 112, in <module>\n  File \"<string>\", line 33, in test_terms_get_should_search_terms_with_filters_excluding_deleted\nAssertionError: Failed to create term, status: 405, body: {\"type\":\"about:blank\",\"title\":\"Method Not Allowed\",\"status\":405,\"detail\":\"Method 'POST' is not supported.\",\"instance\":\"/api/v1/terms\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.144Z",
    "modified": "2025-12-23T13:02:54.800Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "2097a0c7-ce39-4299-8d99-12eced560b01",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC007-terms post should create_term_and_store_initial_en_capitalized",
    "description": "Test the /api/v1/terms POST endpoint to create a new term and verify that the initial_en field is automatically set to the uppercase first letter of name_en.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\n\ndef test_terms_post_should_create_term_and_store_initial_en_capitalized():\n    url = f\"{BASE_URL}/api/v1/terms\"\n    term_data = {\n        \"name_en\": \"exampleName\",\n        \"name_ko\": \"예제명\",  # assuming the schema requires other fields e.g. Korean name\n        \"abbreviation\": \"EX\",\n        \"description\": \"Description for example term\",\n        \"synonyms\": [\"exTerm\", \"sampleTerm\"],\n        \"hashtags\": [\"#example\", \"#term\"],\n        \"process_ids\": []  # assuming terms can be linked to processes\n    }\n\n    created_id = None\n\n    try:\n        # Create term\n        response = requests.post(url, json=term_data, headers=HEADERS, timeout=30)\n        assert response.status_code == 201 or response.status_code == 200, f\"Unexpected status code: {response.status_code}, response: {response.text}\"\n        json_resp = response.json()\n        # The response should contain the created term details including an ID and initial_en\n\n        created_id = json_resp.get(\"id\") or json_resp.get(\"termId\")\n        assert created_id is not None, \"Response does not contain term ID\"\n\n        # Verify the initial_en field is set to uppercase first letter of name_en\n        initial_en = json_resp.get(\"initial_en\")\n        assert initial_en is not None, \"initial_en field is missing in response\"\n        expected_initial = term_data[\"name_en\"][0].upper()\n        assert initial_en == expected_initial, f\"initial_en expected '{expected_initial}', got '{initial_en}'\"\n\n    finally:\n        # Cleanup: delete created term if created\n        if created_id:\n            del_url = f\"{BASE_URL}/api/v1/terms/{created_id}\"\n            del_response = requests.delete(del_url, headers=HEADERS, timeout=30)\n            assert del_response.status_code == 204 or del_response.status_code == 200, f\"Failed to delete term with id {created_id}, status: {del_response.status_code}\"\n\n\ntest_terms_post_should_create_term_and_store_initial_en_capitalized()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 50, in <module>\n  File \"<string>\", line 29, in test_terms_post_should_create_term_and_store_initial_en_capitalized\nAssertionError: Unexpected status code: 405, response: {\"type\":\"about:blank\",\"title\":\"Method Not Allowed\",\"status\":405,\"detail\":\"Method 'POST' is not supported.\",\"instance\":\"/api/v1/terms\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.148Z",
    "modified": "2025-12-23T13:02:55.874Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "909e7762-e5f0-48fc-bd98-7057594f78af",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC008-terms id get should_return_term_detail_or_404_if_deleted",
    "description": "Test the /api/v1/terms/{id} GET endpoint to retrieve term details and verify it returns 404 if the term is soft deleted.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\n\ndef test_terms_id_get_should_return_term_detail_or_404_if_deleted():\n    # 1. Create a new term\n    create_payload = {\n        \"name_kr\": \"테스트용어_TC008\",\n        \"name_en\": \"TestTermTC008\",\n        \"abbreviation\": \"TTC008\",\n        \"description\": \"This is a test term created for TC008.\",\n        \"synonyms\": [\"TestTermSynonym\"],\n        \"related_processes\": [\"TestProcess1\"],\n        \"hashtags\": [\"#test\", \"#term\"]\n    }\n    term_id = None\n    try:\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/v1/terms\",\n            headers=HEADERS,\n            json=create_payload,\n            timeout=30\n        )\n        assert create_resp.status_code == 201, f\"Term creation failed: {create_resp.text}\"\n        term_json = create_resp.json()\n        term_id = term_json.get(\"id\")\n        assert term_id is not None, \"Created term ID not found\"\n\n        # 2. Get the created term detail (should succeed)\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/v1/terms/{term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert get_resp.status_code == 200, f\"Failed to get term detail: {get_resp.text}\"\n        get_json = get_resp.json()\n        assert get_json.get(\"id\") == term_id, \"Returned term ID mismatch\"\n        assert get_json.get(\"name_en\") == create_payload[\"name_en\"], \"Term name_en mismatch\"\n        assert get_json.get(\"initial_en\") == create_payload[\"name_en\"][0].upper(), \"Term initial_en mismatch\"\n\n        # 3. Soft delete the term\n        delete_resp = requests.delete(\n            f\"{BASE_URL}/api/v1/terms/{term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert delete_resp.status_code == 204, f\"Failed to delete term: {delete_resp.text}\"\n\n        # 4. Try to get the term detail again after deletion - expect 404\n        get_deleted_resp = requests.get(\n            f\"{BASE_URL}/api/v1/terms/{term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert get_deleted_resp.status_code == 404, f\"Deleted term still accessible: {get_deleted_resp.text}\"\n\n    finally:\n        # Cleanup: ensure the term is deleted if it still exists (just in case)\n        if term_id:\n            requests.delete(\n                f\"{BASE_URL}/api/v1/terms/{term_id}\",\n                headers=HEADERS,\n                timeout=10\n            )\n\ntest_terms_id_get_should_return_term_detail_or_404_if_deleted()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 72, in <module>\n  File \"<string>\", line 30, in test_terms_id_get_should_return_term_detail_or_404_if_deleted\nAssertionError: Term creation failed: {\"type\":\"about:blank\",\"title\":\"Method Not Allowed\",\"status\":405,\"detail\":\"Method 'POST' is not supported.\",\"instance\":\"/api/v1/terms\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.153Z",
    "modified": "2025-12-23T13:03:14.895Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "8cec7360-476a-4ab5-ad23-6f7ced76258f",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC009-suggestions post should_create_new_term_suggestion",
    "description": "Test the /api/v1/suggestions POST endpoint to create a new term suggestion by a user with ROLE_USER.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_suggestions_post_should_create_new_term_suggestion():\n    url = f\"{BASE_URL}/api/v1/suggestions\"\n    suggestion_payload = {\n        \"name_ko\": \"테스트 용어명\",\n        \"name_en\": \"TestTerm\",\n        \"description\": \"This is a test term suggestion created by automation.\",\n        \"abbreviation\": \"TT\",\n        \"synonyms\": [\"TestTermSyn1\", \"TestTermSyn2\"],\n        \"processIds\": [\"process1\", \"process2\"],\n        \"hashtags\": [\"#test\", \"#automation\"]\n    }\n\n    response = None\n    suggestion_id = None\n    try:\n        response = requests.post(url, json=suggestion_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert response.status_code == 201 or response.status_code == 200, f\"Expected status 200 or 201 but got {response.status_code}\"\n        response_json = response.json()\n        assert \"id\" in response_json, \"Response JSON does not contain 'id'\"\n        suggestion_id = response_json[\"id\"]\n        assert suggestion_id is not None and str(suggestion_id).strip() != \"\", \"Suggestion id is empty\"\n        assert response_json.get(\"name_en\") == suggestion_payload[\"name_en\"], \"Returned name_en does not match\"\n    except requests.RequestException as e:\n        assert False, f\"RequestException occurred: {e}\"\n\ntest_suggestions_post_should_create_new_term_suggestion()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 36, in <module>\n  File \"<string>\", line 27, in test_suggestions_post_should_create_new_term_suggestion\nAssertionError: Expected status 200 or 201 but got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.158Z",
    "modified": "2025-12-23T13:03:22.815Z"
  },
  {
    "projectId": "eddf3e6b-87a9-42c9-96a7-0142853750ee",
    "testId": "852ab0cd-8614-4b10-bea0-5044daedc3d4",
    "userId": "34a8b448-20b1-706d-99d0-799e4821154b",
    "title": "TC010-bookmarks terms termid post should_toggle_bookmark_status",
    "description": "Test the /api/v1/bookmarks/terms/{termId} POST endpoint to toggle the bookmark status for a term for the authenticated user.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8080\"\nTOKEN = \"eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJURVNUX0FETUlOIiwiYXV0aCI6IlJPTEVfQURNSU4iLCJleHAiOjE3NjY1ODA5MzN9.Unt_jA9vi_fdKvBFkTbmqI8T5XrTJ8XjrmRsIixPIReaoqXDYLINnMBdzXwzy28nRL7n2Jhv8ZUOr54YrK2AMQ\"\nHEADERS = {\n    \"Authorization\": f\"Bearer {TOKEN}\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_bookmarks_terms_termid_post_should_toggle_bookmark_status():\n    # First create a term to test bookmarking on\n    term_payload = {\n        \"name_kor\": \"테스트용어\",\n        \"name_en\": \"TestTerm\",\n        \"abbreviation\": \"TT\",\n        \"description\": \"This is a test term for bookmark toggle testing.\",\n        \"synonym\": \"TestTermSyn\",\n        \"process_ids\": [],\n        \"photos\": [],\n        \"hashtags\": []\n    }\n\n    term_id = None\n\n    try:\n        # Create term\n        response = requests.post(\n            f\"{BASE_URL}/api/v1/terms\",\n            headers=HEADERS,\n            json=term_payload,\n            timeout=30\n        )\n        assert response.status_code == 201, f\"Failed to create term: {response.text}\"\n        term = response.json()\n        term_id = term.get(\"id\")\n        assert term_id is not None, \"Created term ID is None\"\n\n        # Initial toggle bookmark - should add the bookmark\n        toggle_response_1 = requests.post(\n            f\"{BASE_URL}/api/v1/bookmarks/terms/{term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert toggle_response_1.status_code == 200, f\"Failed to toggle bookmark first time: {toggle_response_1.text}\"\n        resp_data_1 = toggle_response_1.json()\n        # Expect response to indicate bookmarked: True (exact field depends on API, so check keys)\n        assert \"bookmarked\" in resp_data_1, \"Response missing 'bookmarked' field on first toggle\"\n        assert resp_data_1[\"bookmarked\"] is True, \"Expected bookmarked True after first toggle\"\n\n        # Second toggle bookmark - should remove the bookmark\n        toggle_response_2 = requests.post(\n            f\"{BASE_URL}/api/v1/bookmarks/terms/{term_id}\",\n            headers=HEADERS,\n            timeout=30\n        )\n        assert toggle_response_2.status_code == 200, f\"Failed to toggle bookmark second time: {toggle_response_2.text}\"\n        resp_data_2 = toggle_response_2.json()\n        assert \"bookmarked\" in resp_data_2, \"Response missing 'bookmarked' field on second toggle\"\n        assert resp_data_2[\"bookmarked\"] is False, \"Expected bookmarked False after second toggle\"\n\n    finally:\n        # Cleanup: Delete the term created\n        if term_id:\n            delete_response = requests.delete(\n                f\"{BASE_URL}/api/v1/terms/{term_id}\",\n                headers=HEADERS,\n                timeout=30\n            )\n            # We can assert delete status or ignore if resource already deleted\n            assert delete_response.status_code in (204, 200, 202), f\"Failed to delete term: {delete_response.text}\"\n\n\ntest_bookmarks_terms_termid_post_should_toggle_bookmark_status()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 33, in test_bookmarks_terms_termid_post_should_toggle_bookmark_status\nAssertionError: Failed to create term: {\"type\":\"about:blank\",\"title\":\"Method Not Allowed\",\"status\":405,\"detail\":\"Method 'POST' is not supported.\",\"instance\":\"/api/v1/terms\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-23T13:02:22.162Z",
    "modified": "2025-12-23T13:03:18.724Z"
  }
]
